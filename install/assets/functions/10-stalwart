#!/command/with-contenv bash

bootstrap_filesystem() {

    if [ ! -d "${CONFIG_PATH}" ]; then mkdir -p "${CONFIG_PATH}"; fi
    if [ $(stat -c %U "${CONFIG_PATH}") != "stalwart" ] ; then chown -R stalwart:stalwart "${CONFIG_PATH}" ; fi

    if [ ! -d "${DATA_PATH}" ]; then mkdir -p "${DATA_PATH}"; fi
    if [ $(stat -c %U "${DATA_PATH}") != "stalwart" ] ; then chown stalwart:stalwart "${DATA_PATH}" ; fi

    if [ ! -d "${LOG_PATH}" ]; then mkdir -p "${LOG_PATH}" ; fi
    if [ $(stat -c %U "${LOG_PATH}") != "stalwart" ] ; then chown -R stalwart:stalwart "${LOG_PATH}" ; fi

    case "${LOG_TYPE,,}" in
        file )
            create_logrotate stalwart "${LOG_PATH}"/"${LOG_FILE}" stalwart stalwart
        ;;
    esac
}

certificates() {
    TLS_CA_NAME=${TLS_CA_NAME:-"ca-selfsigned-stalwart"}
    TLS_CA_SUBJECT=${TLS_CA_SUBJECT:-"/C=ca/ST=tiredofit/L=docker/O=stalwart/CN="}
    TLS_CA_CERT_SUBJECT=${TLS_CA_CERT_SUBJECT:-${TLS_CA_SUBJECT}${TLS_CA_NAME}}
    TLS_CA_CERT_FILE=${TLS_CA_CERT_FILE:-"/certs/${TLS_CA_NAME}/${TLS_CA_NAME}.crt"}
    TLS_CA_KEY_FILE=${TLS_CA_KEY_FILE:-"$(dirname "${TLS_CA_CERT_FILE}")/${TLS_CA_NAME}.key"}
    TLS_CREATE_CA=${TLS_CREATE_CA:-"TRUE"}

    create_certificate_authority() {
        if [ ! -f "${TLS_CA_CERT_FILE}" ] ; then

            print_debug "[certificates | create_certificate_authority] Creating Self Signed Certificate Authority"
            mkdir -p "$(dirname "${TLS_CA_CERT_FILE}")"
            echo "000a" > "$(dirname "${TLS_CA_CERT_FILE}")"/serial
            touch "$(dirname "${TLS_CA_CERT_FILE}")"/certindex

            silent eval "${ssl_exec} req \
                  -newkey rsa:4096 -keyout ${TLS_CA_KEY_FILE} \
                  -x509 -days 3650 -nodes -out ${TLS_CA_CERT_FILE} \
                  -subj \"${TLS_CA_CERT_SUBJECT}\""

            cat > "$(dirname "${TLS_CA_CERT_FILE}")"/"${TLS_CA_NAME}".conf << EOF
            [ ca ]
            default_ca = ${TLS_CA_NAME}

            [ ${TLS_CA_NAME} ]
            unique_subject = no
            new_certs_dir = .
            certificate = ${TLS_CA_CERT_FILE}
            database = "$(dirname "${TLS_CA_CERT_FILE}")"/certindex
            private_key = ${TLS_CA_KEY_FILE}
            serial = "$(dirname "${TLS_CA_CERT_FILE}")"/serial
            default_days = 3650
            default_md = default
            policy = ${TLS_CA_NAME}_policy
            x509_extensions = ${TLS_CA_NAME}_extensions

            [ ${TLS_CA_NAME}_policy ]
            commonName = supplied
            stateOrProvinceName = supplied
            countryName = supplied
            emailAddress = optional
            organizationName = supplied
            organizationalUnitName = optional

            [ ${TLS_CA_NAME}_extensions ]
            basicConstraints = CA:false
            subjectKeyIdentifier = hash
            authorityKeyIdentifier = keyid:always
            keyUsage = digitalSignature,keyEncipherment
            extendedKeyUsage = serverAuth,clientAuth

            [ req ]
            default_bits = 2048

            [default_conf]
            ssl_conf = ssl_sect

            [ssl_sect]
            system_default = system_default_sect

            [system_default_sect]
            MinProtocol = TLSv1.1
            MaxProtocol = TLSv1.3
            CipherString = DEFAULT
EOF
        else
            print_debug "[certificates | create_certificate_authority] CA Already Exists"
        fi
    }

    create_certificate() {
        if [ "$1" != "" ] ; then
            if var_true "${TLS_CREATE_CA}" ; then
                if [ ! -f "${TLS_CA_CERT_FILE}" ] || [ ! -f "${TLS_CA_KEY_FILE}" ] ; then
                    print_debug "[certificates | create_certificate] No CA Found - Creating before generating certificates"
                    create_certificate_authority
                fi
            fi
            TLS_CERT_SUBJECT="${TLS_CA_SUBJECT}$(basename "${1%%.*}")"

            if var_true "${TLS_CREATE_CA}" ; then
                if [ ! -f "${1%%.*}".key ] ; then
                    print_debug "[certificates | create_certificate] Creating Certificate: ${1}"
                    silent eval "${ssl_exec} req \
                            -newkey rsa:2048 -keyout ${1%%.*}.key \
                          -nodes -out ${1%%.*}.csr \
                          -subj \"${TLS_CERT_SUBJECT}\""
                fi
            else
                if [ ! -f "${1%%.*}".key ] ; then
                    print_debug "[certificates | create_certificate] Creating Certificate: ${1}"
                    silent eval "${ssl_exec} req \
                          -new -x509 -nodes -days 3650
                          -config /tmp/openssl.cnf
                          -out ${1%%.*}.crt \
                          -keyout ${1%%.*}.key"
                fi
            fi

            if var_true "${TLS_CREATE_CA}" ; then
                if [ ! -f "${1%%.*}".cert ] ; then
                    print_debug "[certificates | create_certificate] Signing Certificate: ${1}"
                    silent eval "${ssl_exec} ca -batch -config $(dirname "${TLS_CA_CERT_FILE}")/${CA_NAME}.conf -notext -in ${1%%.*}.csr -out ${1%%.*}.crt"
                    rm -rf "$(tail -n 1 "$(dirname "${TLS_CA_CERT_FILE}")"/certindex | awk '{print $3}').pem"
                    rm -rf "${1%%.*}".csr
                fi
            fi

            if [ -f "${1%%.*}".crt ] && [ -f "${1%%.*}".key ] ; then
                print_debug "[certificates | create_certificate] Merging Certificate and Key for: ${1}"
                   cat "${1%%.*}".crt "${1%%.*}".key > "${1%%.*}".pem
            fi

            if [ ! -f "${1%%.*}"-public.pem ] ; then
                print_debug "[certificates | create_certificate] Creating Public Key for: ${1}"
                silent ${ssl_exec} rsa -in "${1%%.*}".pem -out "${1%%.*}"-public.pem -outform PEM -pubout
            fi
        fi
    }

    check_permissions() {
        if sudo -u postfix [ ! -r "${1}" ] ; then
            print_debug "[certificates | check_permissions] Setting Read Permissions on ${1}"
            chmod 444 "${1}"
        fi
    }

    check_certificates() {
        print_debug "[certificates | check_certificates] Checking Existence of ${1}"
        if [ ! -f "${1}" ] ; then
                mkdir -p "$(dirname "${1}")"
                create_certificate "${1}"
        fi
    }

    check_dhparam() {
        print_debug "[certificates | check_dhparam] Checking Existence of ${TLS_SERVER_DH_PARAM_FILE}"
        if [ ! -f "${TLS_SERVER_DH_PARAM_FILE}" ] ; then
                create_dhparam
        fi
    }

    create_dhparam() {
        print_notice "[certificates | create_dhparam] Creating ${TLS_SERVER_DH_PARAM_FILE}"
        mkdir -p "$(dirname "${TLS_SERVER_DH_PARAM_FILE}")"
        silent ${ssl_exec} dhparam -out "${TLS_SERVER_DH_PARAM_FILE}" "${TLS_SERVER_DH_PARAM_KEYSIZE}"
    }

    trust_ca() {
        if var_true "${TLS_CREATE_CA}" ; then
            if [ -f "${TLS_CA_CERT_FILE}" ]; then
                if [ ! -f /usr/local/share/ca-certificates/"$(basename "${TLS_CA_CERT_FILE}")" ] ; then
                    print_debug "[certificates | trust_ca] Trusting CA ${TLS_CA_NAME}"
                    ln -sf "${TLS_CA_CERT_FILE}" /usr/local/share/ca-certificates/
                    silent update-ca-certificates
                fi
            fi
        fi
    }

    if ! command -v openssl &> /dev/null && ! command -v libressl &> /dev/null ; then
        print_error "[certificates] Can't find a suitable SSL engine - Exiting.."
        exit 1
    fi

    if command -v libressl &> /dev/null ; then
        ssl_exec="libressl"
    fi

    if command -v openssl &> /dev/null ; then
        ssl_exec="openssl"
    fi

    if command -v openssl &> /dev/null &&  command -v libressl &> /dev/null ; then
        ssl_exec="openssl"
    fi

    case "${1,,}" in
        "dhparam" )
            check_dhparam
        ;;
        *)
            check_certificates "${1}"
            check_permissions "${1}"
            trust_ca
        ;;
    esac
}

configure_common() {

    local config_dir
    local config_file

    config_dir="${CONFIG_PATH}/common"

    common_configure_server() {
        if [ "${SETUP_TYPE,,}" = "auto" ]; then
            if [ ! -d "${config_dir}" ]; then mkdir -p "${config_dir}" ; fi
            config_file="server.toml"
            config_files=$(echo ${config_files} ; echo "${config_dir}/${config_file},")

            toml_block add server hostname "\"${SERVER_NAME}"\"

            toml_block add server.run-as user stalwart
            toml_block add server.run-as group stalwart

            toml_block add server.socket nodelay ${SERVER_SOCKET_NODELAY}
            toml_block add server.socket reuse-addr ${SERVER_SOCKET_REUSE_ADDR}
            toml_block add server.socket backlog ${SERVER_SOCKET_BACKLOG}
            toml_block add global shared-map "\$"${GLOBAL_SHARED_MAP}"\"

            cat <<EOF > "${config_dir}"/"${config_file}"
##########################################################
# Server configuration ${config_file}
# Automatically Generated on  $(date +'%Y-%m-%d %H:%M:%S')
##########################################################

${block_server}

${block_server_run_as}

${block_server_socket}

${block_global}

EOF
            sed -i 'N;/^\n$/D;P;D;' "${config_dir}"/"${config_file}"
        else
            :
        fi


    }

    common_configure_sieve() {
        config_file="sieve.toml"

        if [ "${SETUP_TYPE,,}" = "auto" ]; then
            config_files=$(echo ${config_files} ; echo "${config_dir}/${config_file},")
            cat <<EOF > "${config_dir}"/"${config_file}"
##########################################################
# Common configuration ${config_file}
# Automatically Generated on  $(date +'%Y-%m-%d %H:%M:%S')
##########################################################


#############################################
# Sieve untrusted runtime configuration
#############################################

[sieve.untrusted]
disable-capabilities = []
notification-uris = ["mailto"]
protected-headers = ["Original-Subject", "Original-From", "Received", "Auto-Submitted"]

[sieve.untrusted.limits]
name-length = 512
max-scripts = 256
script-size = 102400
string-length = 4096
variable-name-length = 32
variable-size = 4096
nested-blocks = 15
nested-tests = 15
nested-foreverypart = 3
match-variables = 30
local-variables = 128
header-size = 1024
includes = 3
nested-includes = 3
cpu = 5000
redirects = 1
received-headers = 10
outgoing-messages = 3

[sieve.untrusted.vacation]
default-subject = "Automated reply"
subject-prefix = "Auto: "

[sieve.untrusted.default-expiry]
vacation = "30d"
duplicate = "7d"

#############################################
# Sieve trusted runtime configuration
#############################################

[sieve.trusted]
from-name = "Automated Message"
from-addr = "no-reply@%{DEFAULT_DOMAIN}%"
return-path = ""
#hostname = "%{HOST}%"
no-capability-check = true
sign = ["rsa"]

[sieve.trusted.limits]
redirects = 3
out-messages = 5
received-headers = 50
cpu = 1048576
nested-includes = 5
duplicate-expiry = "7d"

[sieve.trusted.scripts]
#connect = '''require ["variables", "extlists", "reject"];
#    if string :list "${env.remote_ip}" "default/blocked-ips" {
#        reject "Your IP '${env.remote_ip}' is not welcomed here.";
#    }'''

#ehlo = '''require ["variables", "extlists", "reject"];
#    if string :list "${env.helo_domain}" "default/blocked-domains" {
#        reject "551 5.1.1 Your domain '${env.helo_domain}' has been blacklisted.";
#    }'''

#mail = '''require ["variables", "envelope", "reject"];
#    if envelope :localpart :is "from" "known_spammer" {
#        reject "We do not accept SPAM.";
#    }'''

EOF
        else
            :
        fi
    }

    common_configure_tls() {
        config_file="tls.toml"
        config_files=$(echo ${config_files} ; echo "${config_dir}/${config_file},")
        if [ "${SETUP_TYPE,,}" = "auto" ]; then
            certificates "${TLS_DEFAULT_CERT_FILE}"

            toml_block add server.tls enable true
            toml_block add server.tls implicit false
            toml_block add server.tls timeout "\"1m"\"
            toml_block add server.tls certificate "\"default"\"
            ## TODO Be able to create arrays
            toml_block add server.tls ignore-client-order true
            ## TODO Test if we can do TOML blocks without quotes for certificate
            cat <<EOF > "${config_dir}"/"${config_file}"
##########################################################
# Common configuration ${config_file}
# Automatically Generated on  $(date +'%Y-%m-%d %H:%M:%S')
##########################################################

${block_server_tls}

[certificate."default"]
cert = "file:///${TLS_DEFAULT_CERT_FILE}"
private-key = "file:///${TLS_DEFAULT_KEY_FILE}"
EOF
        else
            :
        fi
    }

    common_configure_tracing() {
        config_file="tracing.toml"
        config_files=$(echo ${config_files} ; echo "${config_dir}/${config_file},")
        if [ "${SETUP_TYPE,,}" = "auto" ]; then

            case "${LOG_TYPE,,}" in
                ## TODO Allow for comma seperated and allow for multiple blocks with same name
                "console" )
                    toml_block add global.tracing method "\"stdout"\"
                    toml_block add global.tracing level "\"${LOG_LEVEL}"\"
                ;;
                "file" )
                    toml_block add global.tracing method log
                    toml_block add global.tracing path "\"${LOG_PATH}"\"
                    toml_block add global.tracing prefix "\"${LOG_FILE}"\"
                    toml_block add global.tracing level "\"${LOG_LEVEL}"\"
                    toml_block add global.tracing rotate "\"never\""
                    toml_block add global.tracing ansi false
                ;;
            esac
            cat <<EOF > "${config_dir}"/"${config_file}"
##########################################################
# Loggina and Tracing configuration ${config_file}
# Automatically Generated on  $(date +'%Y-%m-%d %H:%M:%S')
##########################################################

${block_global_tracing}

EOF
        else
            :
        fi
    }

    common_configure_server
    if var_true ${ENABLE_SIEVE} ; then common_configure_sieve; fi
    if var_true ${ENABLE_TLS} ; then common_configure_tls; fi
    common_configure_tracing
}

configure_directory() {

    local config_dir
    local config_file

    config_dir="${CONFIG_PATH}/directory"

    directory_configure_imap() {
        ## TODO - Future version
        if [ "${SETUP_TYPE,,}" = "auto" ]; then
            :
        else
            :
        fi
:
    }

    directory_configure_ldap() {
        config_file="ldap.toml"
        config_files=$(echo ${config_files} ; echo "${config_dir}/${config_file},")
        if [ "${SETUP_TYPE,,}" = "auto" ]; then
            cat <<EOF > "${config_dir}"/"${config_file}"
##########################################################
# Common configuration ${config_file}
# Automatically Generated on  $(date +'%Y-%m-%d %H:%M:%S')
##########################################################

#############################################
# LDAP Directory configuration
#############################################

[directory."default"]
type = "ldap"
address = "ldap://localhost:3893"
base-dn = "dc=example,dc=org"

[directory."default".bind]
dn = "cn=serviceuser,ou=svcaccts,dc=example,dc=org"
secret = "mysecret"

[directory."default".cache]
entries = 500
ttl = {positive = '1h', negative = '10m'}

[directory."default".options]
catch-all = true
#catch-all = { map = "(.+)@(.+)$", to = "info@${2}" }
subaddressing = true
#subaddressing = { map = "^([^.]+)\.([^.]+)@(.+)$", to = "${2}@${3}" }
superuser-group = "superusers"

[directory."default".pool]
max-connections = 10
min-connections = 0
max-lifetime = "30m"
idle-timeout = "10m"
connect-timeout = "30s"

[directory."default".filter]
name = "(&(|(objectClass=posixAccount)(objectClass=posixGroup))(uid=?))"
email = "(&(|(objectClass=posixAccount)(objectClass=posixGroup))(|(mail=?)(mailAlias=?)(mailList=?)))"
verify = "(&(|(objectClass=posixAccount)(objectClass=posixGroup))(|(mail=*?*)(mailAlias=*?*)))"
expand = "(&(|(objectClass=posixAccount)(objectClass=posixGroup))(mailList=?))"
domains = "(&(|(objectClass=posixAccount)(objectClass=posixGroup))(|(mail=*@?)(mailAlias=*@?)))"

[directory."default".object-classes]
user = "posixAccount"
group = "posixGroup"

[directory."default".attributes]
name = "uid"
description = ["principalName", "description"]
secret = "userPassword"
groups = ["memberOf", "otherGroups"]
email = "mail"
email-alias = "mailAlias"
quota = "diskQuota"

EOF
        else
            :
        fi
    }

    directory_configure_lmtp() {
        ## TODO - Future version
        if [ "${SETUP_TYPE,,}" = "auto" ]; then
            :
        else
            :
        fi
    }

    directory_configure_memory() {
        ## TODO - Future version
        if [ "${SETUP_TYPE,,}" = "auto" ]; then
            :
        else
            :
        fi
    }

    directory_configure_sql() {
        ## TODO - Future version to support SQLite, MariaDB, and Postgres
        if [ "${SETUP_TYPE,,}" = "auto" ]; then
            :
        else
            :
        fi
    }

}

configure_imap() {
    local config_dir
    local config_file

    config_dir="${CONFIG_PATH}/imap"

    imap_configure_listener() {
        ## TODO - Future version
        if [ "${SETUP_TYPE,,}" = "auto" ]; then
            :
        else
            :
        fi
    }

    imap_configure_settings() {
        ## TODO - Future version
        if [ "${SETUP_TYPE,,}" = "auto" ]; then
            :
        else
            :
        fi
    }
}

configure_jmap() {
    local config_dir
    local config_file

    config_dir="${CONFIG_PATH}/jmap"

    jmap_configure_auth() {
        ## TODO - Future version
        if [ "${SETUP_TYPE,,}" = "auto" ]; then
            :
        else
            :
        fi
    }

    jmap_configure_listener() {
        ## TODO - Future version
        if [ "${SETUP_TYPE,,}" = "auto" ]; then
            :
        else
            :
        fi
    }

    jmap_configure_oauth() {
        ## TODO - Future version
        if [ "${SETUP_TYPE,,}" = "auto" ]; then
            :
        else
            :
        fi
    }

    jmap_configure_protocol() {
        ## TODO - Future version
        if [ "${SETUP_TYPE,,}" = "auto" ]; then
            :
        else
            :
        fi
    }

    jmap_configure_push() {
        ## TODO - Future version
        if [ "${SETUP_TYPE,,}" = "auto" ]; then
            :
        else
            :
        fi
    }

    jmap_configure_ratelimit() {
        ## TODO - Future version
        if [ "${SETUP_TYPE,,}" = "auto" ]; then
            :
        else
            :
        fi
    }

    jmap_configure_store() {
        ## TODO - Future version
        if [ "${SETUP_TYPE,,}" = "auto" ]; then
            :
        else
            :
        fi
    }

    jmap_configure_websockets() {
        ## TODO - Future version
        if [ "${SETUP_TYPE,,}" = "auto" ]; then
            :
        else
            :
        fi
    }
}

configure_spamfilter() {
    local config_dir
    local config_file

    config_dir="${CONFIG_PATH}/spamfilter"

    ## TODO - Future version
    :
}

configure_smtp() {
    local config_dir
    local config_file

    config_dir="${CONFIG_PATH}/smtp"

    smtp_configure_auth() {
        config_file="auth.toml"
        config_files=$(echo ${config_files} ; echo "${config_dir}/${config_file},")
        if [ "${SETUP_TYPE,,}" = "auto" ]; then
            cat <<EOF > "${config_dir}"/"${config_file}"
##########################################################
# SMTP configuration ${config_file}
# Automatically Generated on  $(date +'%Y-%m-%d %H:%M:%S')
##########################################################

#############################################
# SMTP DMARC, DKIM, SPF, ARC & IpRev
#############################################

[auth.iprev]
verify = [ { if = "listener", eq = "smtp", then = "relaxed" },
           { else = "disable" } ]

[auth.dkim]
verify = "relaxed"
sign = [ { if = "listener", ne = "smtp", then = ["rsa"] },
         { else = [] } ]

[auth.spf.verify]
ehlo = [ { if = "listener", eq = "smtp", then = "relaxed" },
         { else = "disable" } ]
mail-from = [ { if = "listener", eq = "smtp", then = "relaxed" },
              { else = "disable" } ]

[auth.arc]
verify = "relaxed"
seal = ["rsa"]

[auth.dmarc]
verify = [ { if = "listener", eq = "smtp", then = "relaxed" },
           { else = "disable" } ]

EOF
        else
            :
        fi
    }

    smtp_configure_dkim() {
        config_file="dkim.toml"
        config_files=$(echo ${config_files} ; echo "${config_dir}/${config_file},")
        if [ "${SETUP_TYPE,,}" = "auto" ]; then
            cat <<EOF > "${config_dir}"/"${config_file}"
##########################################################
# SMTP configuration ${config_file}
# Automatically Generated on  $(date +'%Y-%m-%d %H:%M:%S')
##########################################################

EOF
        else
            :
        fi
    }

    smtp_configure_listener() {
        config_file="listener.toml"
        config_files=$(echo ${config_files} ; echo "${config_dir}/${config_file},")
        if [ "${SETUP_TYPE,,}" = "auto" ]; then
            cat <<EOF > "${config_dir}"/"${config_file}"
##########################################################
# SMTP configuration ${config_file}
# Automatically Generated on  $(date +'%Y-%m-%d %H:%M:%S')
##########################################################

#############################################
# SMTP server listener configuration
#############################################

[server.listener."smtp"]
bind = ["[::]:25"]
#greeting = "Stalwart SMTP at your service"
protocol = "smtp"

[server.listener."submission"]
bind = ["[::]:587"]
protocol = "smtp"

[server.listener."submissions"]
bind = ["[::]:465"]
protocol = "smtp"
tls.implicit = true

[server.listener."management"]
bind = ["127.0.0.1:8080"]
protocol = "http"

[management]
directory = "default"

EOF
        else
            :
        fi
    }

    smtp_configure_milter() {
        config_file="milter.toml"
        config_files=$(echo ${config_files} ; echo "${config_dir}/${config_file},")
        if [ "${SETUP_TYPE,,}" = "auto" ]; then
            cat <<EOF > "${config_dir}"/"${config_file}"
##########################################################
# SMTP configuration ${config_file}
# Automatically Generated on  $(date +'%Y-%m-%d %H:%M:%S')
##########################################################

#############################################
# SMTP inbound Milter configuration
#############################################

#[session.data.milter."rspamd"]
#enable = [ { if = "listener", eq = "smtp", then = true },
#           { else = false } ]
#hostname = "127.0.0.1"
#port = 11332
#tls = false
#allow-invalid-certs = false

#[session.data.milter."rspamd".timeout]
#connect = "30s"
#command = "30s"
#data = "60s"

#[session.data.milter."rspamd".options]
#tempfail-on-error = true
#max-response-size = 52428800 # 50mb
#version = 6

#[session.data.pipe."spam-assassin"]
#command = "spamc"
#arguments = []
#timeout = "10s"

EOF
        else
            :
        fi
    }

    smtp_configure_queue() {
        config_file="queue.toml"
        config_files=$(echo ${config_files} ; echo "${config_dir}/${config_file},")
        if [ "${SETUP_TYPE,,}" = "auto" ]; then
            cat <<EOF > "${config_dir}"/"${config_file}"
##########################################################
# SMTP configuration ${config_file}
# Automatically Generated on  $(date +'%Y-%m-%d %H:%M:%S')
##########################################################

#############################################
# SMTP server queue configuration
#############################################

[queue]
path = "%{BASE_PATH}%/queue"
hash = 64

[queue.schedule]
retry = ["2m", "5m", "10m", "15m", "30m", "1h", "2h"]
notify = ["1d", "3d"]
expire = "5d"

[queue.outbound]
#hostname = "%{HOST}%"
next-hop = [ { if = "rcpt-domain", in-list = "default/domains", then = "local" },
             { else = false } ]
ip-strategy = "ipv4-then-ipv6"

[queue.outbound.tls]
dane = "optional"
mta-sts = "optional"
starttls = "require"
allow-invalid-certs = false

#[queue.outbound.source-ip]
#v4 = ["10.0.0.10", "10.0.0.11"]
#v6 = ["a::b", "a::c"]

[queue.outbound.limits]
mx = 7
multihomed = 2

[queue.outbound.timeouts]
connect = "3m"
greeting = "3m"
tls = "2m"
ehlo = "3m"
mail-from = "3m"
rcpt-to = "3m"
data = "10m"
mta-sts = "2m"

[[queue.quota]]
#match = {if = "sender-domain", eq = "foobar.org"}
#key = ["rcpt"]
messages = 100000
size = 10737418240 # 10gb

[[queue.throttle]]
key = ["rcpt-domain"]
#rate = "100/1h"
concurrency = 5

EOF
        else
            :
        fi
    }

    smtp_configure_remote() {
        config_file="remote.toml"
        config_files=$(echo ${config_files} ; echo "${config_dir}/${config_file},")
        if [ "${SETUP_TYPE,,}" = "auto" ]; then
            cat <<EOF > "${config_dir}"/"${config_file}"
##########################################################
# SMTP configuration ${config_file}
# Automatically Generated on  $(date +'%Y-%m-%d %H:%M:%S')
##########################################################
#############################################
# SMTP remote servers configuration
#############################################

[remote."local"]
address = "127.0.0.1"
port = 11200
protocol = "lmtp"
concurrency = 10
timeout = "1m"

[remote."local".tls]
implicit = false
allow-invalid-certs = true

#[remote."local".auth]
#username = ""
#secret = ""
EOF
        else
            :
        fi
    }

    smtp_configure_report() {
        config_file="report.toml"
        config_files=$(echo ${config_files} ; echo "${config_dir}/${config_file},")
        if [ "${SETUP_TYPE,,}" = "auto" ]; then
            cat <<EOF > "${config_dir}"/"${config_file}"
##########################################################
# SMTP configuration ${config_file}
# Automatically Generated on  $(date +'%Y-%m-%d %H:%M:%S')
##########################################################

#############################################
# SMTP reporting configuration
#############################################

[report]
path = "%{BASE_PATH}%/reports"
hash = 64
#submitter = "%{HOST}%"

[report.analysis]
addresses = ["dmarc@*", "abuse@*", "postmaster@*"]
forward = true
#store = "%{BASE_PATH}%/incoming"

[report.dsn]
from-name = "Mail Delivery Subsystem"
from-address = "MAILER-DAEMON@%{DEFAULT_DOMAIN}%"
sign = ["rsa"]

[report.dkim]
from-name = "Report Subsystem"
from-address = "noreply-dkim@%{DEFAULT_DOMAIN}%"
subject = "DKIM Authentication Failure Report"
sign = ["rsa"]
send = "1/1d"

[report.spf]
from-name = "Report Subsystem"
from-address = "noreply-spf@%{DEFAULT_DOMAIN}%"
subject = "SPF Authentication Failure Report"
send = "1/1d"
sign = ["rsa"]

[report.dmarc]
from-name = "Report Subsystem"
from-address = "noreply-dmarc@%{DEFAULT_DOMAIN}%"
subject = "DMARC Authentication Failure Report"
send = "1/1d"
sign = ["rsa"]

[report.dmarc.aggregate]
from-name = "DMARC Report"
from-address = "noreply-dmarc@%{DEFAULT_DOMAIN}%"
org-name = "%{DEFAULT_DOMAIN}%"
#contact-info = ""
send = "daily"
max-size = 26214400 # 25mb
sign = ["rsa"]

[report.tls.aggregate]
from-name = "TLS Report"
from-address = "noreply-tls@%{DEFAULT_DOMAIN}%"
org-name = "%{DEFAULT_DOMAIN}%"
#contact-info = ""
send = "daily"
max-size = 26214400 # 25 mb
sign = ["rsa"]

EOF
        else
            :
        fi
    }

    smtp_configure_resolver() {
        config_file="resolver.toml"
        config_files=$(echo ${config_files} ; echo "${config_dir}/${config_file},")
        if [ "${SETUP_TYPE,,}" = "auto" ]; then
            cat <<EOF > "${config_dir}"/"${config_file}"
##########################################################
# SMTP configuration ${config_file}
# Automatically Generated on  $(date +'%Y-%m-%d %H:%M:%S')
##########################################################

#############################################
# SMTP server resolver configuration
#############################################

[resolver]
type = "system"
#preserve-intermediates = true
concurrency = 2
timeout = "5s"
attempts = 2
try-tcp-on-error = true
public-suffix = ["https://publicsuffix.org/list/public_suffix_list.dat",
                 "file://%{BASE_PATH}%/etc/spamfilter/maps/suffix_list.dat.gz"]

[resolver.cache]
txt = 2048
mx = 1024
ipv4 = 1024
ipv6 = 1024
ptr = 1024
tlsa = 1024
mta-sts = 1024

EOF
        else
            :
        fi
    }

    smtp_configure_session() {
        config_file="session.toml"
        config_files=$(echo ${config_files} ; echo "${config_dir}/${config_file},")
        if [ "${SETUP_TYPE,,}" = "auto" ]; then
            cat <<EOF > "${config_dir}"/"${config_file}"
##########################################################
# SMTP configuration ${config_file}
# Automatically Generated on  $(date +'%Y-%m-%d %H:%M:%S')
##########################################################

#############################################
# SMTP inbound session configuration
#############################################

[session]
timeout = "5m"
transfer-limit = 262144000 # 250 MB
duration = "10m"

[session.connect]
#script = "connect.sieve"

[session.ehlo]
require = true
reject-non-fqdn = [ { if = "listener", eq = "smtp", then = true},
                    { else = false } ]
#script = "ehlo"

[session.extensions]
pipelining = true
chunking = true
requiretls = true
no-soliciting = ""
dsn = [ { if = "authenticated-as", ne = "", then = true},
        { else = false } ]
expn = [ { if = "authenticated-as", ne = "", then = true},
        { else = false } ]
vrfy = [ { if = "authenticated-as", ne = "", then = true},
        { else = false } ]
future-release = [ { if = "authenticated-as", ne = "", then = "7d"},
                   { else = false } ]
deliver-by = [ { if = "authenticated-as", ne = "", then = "15d"},
               { else = false } ]
mt-priority = [ { if = "authenticated-as", ne = "", then = "mixer"},
                { else = false } ]

[session.auth]
mechanisms = [ { if = "listener", ne = "smtp", then = ["plain", "login"]},
               { else = [] } ]
directory = [ { if = "listener", ne = "smtp", then = "default" },
           { else = false } ]
require = [ { if = "listener", ne = "smtp", then = true},
            { else = false } ]
allow-plain-text = false

[session.auth.errors]
total = 3
wait = "5s"

[session.mail]
#script = "mail-from"
#rewrite = [ { all-of = [ { if = "listener", ne = "smtp" },
#                         { if = "rcpt", matches = "^([^.]+)@([^.]+)\.(.+)$"},
#                       ], then = "${1}@${3}" },
#            { else = false } ]

[session.rcpt]
#script = "greylist"
relay = [ { if = "authenticated-as", ne = "", then = true },
          { else = false } ]
#rewrite = [ { all-of = [ { if = "rcpt-domain", in-list = "default/domains" },
#                         { if = "rcpt", matches = "^([^.]+)\.([^.]+)@(.+)$"},
#                       ], then = "${1}+${2}@${3}" },
#            { else = false } ]
max-recipients = 25
directory = "default"

[session.rcpt.errors]
total = 5
wait = "5s"

[session.data]
script = [ { if = "authenticated-as", eq = "", then = "spam-filter"},
           { else = "track-replies" } ]

[session.data.limits]
messages = 10
size = 104857600
received-headers = 50

[session.data.add-headers]
received = [ { if = "listener", eq = "smtp", then = true },
             { else = false } ]
received-spf = [ { if = "listener", eq = "smtp", then = true },
                 { else = false } ]
auth-results = [ { if = "listener", eq = "smtp", then = true },
                 { else = false } ]
message-id = [ { if = "listener", eq = "smtp", then = false },
               { else = true } ]
date = [ { if = "listener", eq = "smtp", then = false },
         { else = true } ]
return-path = false

[[session.throttle]]
#match = {if = "remote-ip", eq = "10.0.0.1"}
key = ["remote-ip"]
concurrency = 5
#rate = "5/1h"

[[session.throttle]]
key = ["sender-domain", "rcpt"]
rate = "25/1h"

EOF
        else
            :
        fi
    }

    smtp_configure_signature() {
        config_file="signature.toml"
        config_files=$(echo ${config_files} ; echo "${config_dir}/${config_file},")
        if [ "${SETUP_TYPE,,}" = "auto" ]; then
            cat <<EOF > "${config_dir}"/"${config_file}"
##########################################################
# SMTP configuration ${config_file}
# Automatically Generated on  $(date +'%Y-%m-%d %H:%M:%S')
##########################################################

#############################################
# SMTP DKIM & ARC signatures
#############################################

[signature."rsa"]
#public-key = "file://%{BASE_PATH}%/etc/dkim/%{DEFAULT_DOMAIN}%.cert"
private-key = "file://%{BASE_PATH}%/etc/dkim/%{DEFAULT_DOMAIN}%.key"
domain = "%{DEFAULT_DOMAIN}%"
selector = "stalwart"
headers = ["From", "To", "Date", "Subject", "Message-ID"]
algorithm = "rsa-sha256"
canonicalization = "relaxed/relaxed"
#expire = "10d"
#third-party = ""
#third-party-algo = ""
#auid = ""
set-body-length = false
report = true

EOF
        else
            :
        fi
    }

    smtp_configure_spamfilter() {
        config_file="spamfilter.toml"
        config_files=$(echo ${config_files} ; echo "${config_dir}/${config_file},")
        if [ "${SETUP_TYPE,,}" = "auto" ]; then
            cat <<EOF > "${config_dir}"/"${config_file}"
##########################################################
# SMTP configuration ${config_file}
# Automatically Generated on  $(date +'%Y-%m-%d %H:%M:%S')
##########################################################

#############################################
# SMTP Spam & Phishing filter configuration
#############################################

[directory."spamdb"]
type = "sql"
address = "sqlite://%{BASE_PATH}%/data/spamfilter.sqlite3?mode=rwc"

[directory."spamdb".pool]
max-connections = 10
min-connections = 0
idle-timeout = "5m"

[directory."spamdb".lookup]
token-insert = "INSERT INTO bayes_tokens (h1, h2, ws, wh) VALUES (?, ?, ?, ?)
                ON CONFLICT(h1, h2)
                DO UPDATE SET ws = ws + excluded.ws, wh = wh + excluded.wh"
token-lookup = "SELECT ws, wh FROM bayes_tokens WHERE h1 = ? AND h2 = ?"
id-insert = "INSERT INTO seen_ids (id, ttl) VALUES (?, datetime('now', ? || ' seconds'))"
id-lookup = "SELECT 1 FROM seen_ids WHERE id = ? AND ttl > CURRENT_TIMESTAMP"
reputation-insert = "INSERT INTO reputation (token, score, count, ttl) VALUES (?, ?, 1, datetime('now', '30 days'))
                     ON CONFLICT(token)
                     DO UPDATE SET score = (count + 1) * (excluded.score + 0.98 * score) / (0.98 * count + 1), count = count + 1, ttl = excluded.ttl"
reputation-lookup = "SELECT score, count FROM reputation WHERE token = ?"

[directory."spamdb".schedule]
query = ["DELETE FROM seen_ids WHERE ttl < CURRENT_TIMESTAMP",
         "DELETE FROM reputation WHERE ttl < CURRENT_TIMESTAMP"]
frequency = "0 3 *"

[directory."spam"]
type = "memory"

[directory."spam".lookup."free-domains"]
type = "glob"
comment = '#'
values = ["https://get.stalw.art/resources/config/spamfilter/maps/domains_free.list",
          "file+fallback://%{BASE_PATH}%/etc/spamfilter/maps/domains_free.list"]

[directory."spam".lookup."disposable-domains"]
type = "glob"
comment = '#'
values = ["https://get.stalw.art/resources/config/spamfilter/maps/domains_disposable.list",
          "file+fallback://%{BASE_PATH}%/etc/spamfilter/maps/domains_disposable.list"]

[directory."spam".lookup."redirectors"]
type = "glob"
comment = '#'
values = ["https://get.stalw.art/resources/config/spamfilter/maps/url_redirectors.list",
          "file+fallback://%{BASE_PATH}%/etc/spamfilter/maps/url_redirectors.list"]

[directory."spam".lookup."domains-allow"]
type = "glob"
comment = '#'
values = ["https://get.stalw.art/resources/config/spamfilter/maps/allow_domains.list",
          "file+fallback://%{BASE_PATH}%/etc/spamfilter/maps/allow_domains.list"]

[directory."spam".lookup."dmarc-allow"]
type = "glob"
comment = '#'
values = ["https://get.stalw.art/resources/config/spamfilter/maps/allow_dmarc.list",
          "file+fallback://%{BASE_PATH}%/etc/spamfilter/maps/allow_dmarc.list"]

[directory."spam".lookup."spf-dkim-allow"]
type = "glob"
comment = '#'
values = ["https://get.stalw.art/resources/config/spamfilter/maps/allow_spf_dkim.list",
          "file+fallback://%{BASE_PATH}%/etc/spamfilter/maps/allow_spf_dkim.list"]

[directory."spam".lookup."mime-types"]
type = "map"
comment = '#'
values = ["https://get.stalw.art/resources/config/spamfilter/maps/mime_types.map",
          "file+fallback://%{BASE_PATH}%/etc/spamfilter/maps/mime_types.map"]

[directory."spam".lookup."trap-address"]
type = "glob"
comment = '#'
values = "file://%{BASE_PATH}%/etc/spamfilter/maps/spam_trap.list"

[directory."spam".lookup."scores"]
type = "map"
values = "file://%{BASE_PATH}%/etc/spamfilter/maps/scores.map"

[sieve.trusted.scripts]
spam-filter = ["file://%{BASE_PATH}%/etc/spamfilter/scripts/config.sieve",
               "file://%{BASE_PATH}%/etc/spamfilter/scripts/prelude.sieve",
               "file://%{BASE_PATH}%/etc/spamfilter/scripts/from.sieve",
               "file://%{BASE_PATH}%/etc/spamfilter/scripts/recipient.sieve",
               "file://%{BASE_PATH}%/etc/spamfilter/scripts/subject.sieve",
               "file://%{BASE_PATH}%/etc/spamfilter/scripts/replyto.sieve",
               "file://%{BASE_PATH}%/etc/spamfilter/scripts/date.sieve",
               "file://%{BASE_PATH}%/etc/spamfilter/scripts/messageid.sieve",
               "file://%{BASE_PATH}%/etc/spamfilter/scripts/received.sieve",
               "file://%{BASE_PATH}%/etc/spamfilter/scripts/headers.sieve",
               "file://%{BASE_PATH}%/etc/spamfilter/scripts/bounce.sieve",
               "file://%{BASE_PATH}%/etc/spamfilter/scripts/html.sieve",
               "file://%{BASE_PATH}%/etc/spamfilter/scripts/mime.sieve",
               "file://%{BASE_PATH}%/etc/spamfilter/scripts/dmarc.sieve",
               "file://%{BASE_PATH}%/etc/spamfilter/scripts/ip.sieve",
               "file://%{BASE_PATH}%/etc/spamfilter/scripts/helo.sieve",
               "file://%{BASE_PATH}%/etc/spamfilter/scripts/replies_in.sieve",
               "file://%{BASE_PATH}%/etc/spamfilter/scripts/spamtrap.sieve",
               "file://%{BASE_PATH}%/etc/spamfilter/scripts/bayes_classify.sieve",
               "file://%{BASE_PATH}%/etc/spamfilter/scripts/url.sieve",
               "file://%{BASE_PATH}%/etc/spamfilter/scripts/rbl.sieve",
               "file://%{BASE_PATH}%/etc/spamfilter/scripts/pyzor.sieve",
               "file://%{BASE_PATH}%/etc/spamfilter/scripts/composites.sieve",
               "file://%{BASE_PATH}%/etc/spamfilter/scripts/scores.sieve",
               "file://%{BASE_PATH}%/etc/spamfilter/scripts/reputation.sieve",
               "file://%{BASE_PATH}%/etc/spamfilter/scripts/epilogue.sieve"]

track-replies = ["file://%{BASE_PATH}%/etc/spamfilter/scripts/config.sieve",
                 "file://%{BASE_PATH}%/etc/spamfilter/scripts/replies_out.sieve"]

greylist = "file://%{BASE_PATH}%/etc/spamfilter/scripts/greylist.sieve"

EOF
        else
            :
        fi
    }
}

setup_container_mode() {
    if [ -f "/tmp/.container/stalwart/.mode-env" ]; then
        print_debug "[setup_container_mode] Importing MODE environment generated variables"
        source /tmp/.container/stalwart/.mode-env
    else
        mkdir -p /tmp/.container/stalwart/
        if [ "${MODE,,}" = "aio" ] || [ "${MODE,,}" = "all" ] ; then
            print_debug "[setup_container_mode] Container Mode: AIO"
            print_debug "[setup_container_mode] Creating MODE environment generated variables"
            echo "ENABLE_IMAP=TRUE" >> /tmp/.container/stalwart/.mode-env
            echo "ENABLE_JMAP=TRUE" >> /tmp/.container/stalwart/.mode-env
            echo "ENABLE_SMTP=TRUE" >> /tmp/.container/stalwart/.mode-env
            if [[ "$(grep -cq 'create_log_stalwart=TRUE' /tmp/.container/stalwart/.mode-env)" -eq 0 ]] ; then
                echo "create_log_stalwart=TRUE" >> /tmp/.container/stalwart/.mode-env
            fi
        else
            modes=$(echo "${MODE,,}" | tr "," "\n")
            for mode in $modes; do
                case "${mode,,}" in
                    "imap" )
                        print_debug "[setup_container_mode] Enabling Container Mode for: SMTP"
                        echo "ENABLE_IMAP=TRUE" >> /tmp/.container/stalwart/.mode-env
                        if [[ "$(grep -cq 'create_log_stalwart=TRUE' /tmp/.container/stalwart/.mode-env)" -eq 0 ]] ; then
                            echo "create_log_stalwart=TRUE" >> /tmp/.container/stalwart/.mode-env
                        fi
                    ;;
                    "jmap" )
                        print_debug "[setup_container_mode] Enabling Container Mode for: SMTP"
                        echo "ENABLE_JMAP=TRUE" >> /tmp/.container/stalwart/.mode-env
                        if [[ "$(grep -cq 'create_log_stalwart=TRUE' /tmp/.container/stalwart/.mode-env)" -eq 0 ]] ; then
                            echo "create_log_stalwart=TRUE" >> /tmp/.container/stalwart/.mode-env
                        fi
                    ;;
                    "smtp" )
                        print_debug "[setup_container_mode] Enabling Container Mode for: SMTP"
                        echo "ENABLE_SMTP=TRUE" >> /tmp/.container/stalwart/.mode-env
                        if [[ "$(grep -cq 'create_log_stalwart=TRUE' /tmp/.container/stalwart/.mode-env)" -eq 0 ]] ; then
                            echo "create_log_stalwart=TRUE" >> /tmp/.container/stalwart/.mode-env
                        fi
                    ;;
                    *)
                        print_error "[setup_container_mode] Unknown 'MODE' environment variable - exitting.."
                        exit 1
                    ;;
                esac
            done
        fi
        source /tmp/.container/stalwart/.mode-env
    fi
}

toml_block() {
    ## Usage toml_block <operation> <block> <key> <value>
    ## Access resulting toml block with 'echo $block_<block>'
    ## Any periods or hyphens auto converted to underscore
    case "${1}" in
        add )
            local block_name
            local block_name_sanitized
            local block_data
            if [ -z "${2}" ]; then exit 1; fi
            block_name=${2}
            block_name_sanitized=$(echo "${block_name}" | sed -e "s|\.|_|g" -e "s|-|_|g")
            if [ -n "${4}" ]; then
                block_data=$(echo "${block_data}"; cat<<EOF
${3} = ${4}
EOF
                )
                block_data=$(echo "${block_data}" | sed "/\[.*\]/d" | sed "1s/^/\[${block_name}\]\\n/" | sed "/^$/d")
            fi

            export "block_$block_name_sanitized=$block_data"
            #block_contents=block_$block_name_sanitized
            #echo ${!block_contents}
        ;;
    esac
}
